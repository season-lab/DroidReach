#!/usr/bin/env python3

import argparse
import sys
import os

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), ".."))
from apk_analyzer import APKAnalyzer

def _print_native_functions(apka, libs=None, reachable=False):
    methods = None
    if reachable:
        methods = apka.find_reachable_native_methods()
    else:
        methods = apka.find_native_methods()

    for class_name, method_name, args_str in methods:
        print(" %s %s %s" % (class_name, method_name, args_str))
        native_impls = apka.find_native_implementations(method_name, class_name, args_str, libs)
        if len(native_impls) == 0:
            print("   * no implementation found")
            continue

        for native_impl in native_impls:
            print("   * %s\t%#x" % (native_impl.analyzer.libpath, native_impl.offset))

def _find_producer(apka, consumer, libs=None, reachable=False):
    class_name  = "L" + "/".join(consumer.split(".")[:-1]) + ";"
    method_name = consumer.split(".")[-1]

    consumer_impl = None
    for method in apka.find_native_methods_implementations(libs, reachable):
        if method.class_name == class_name and method.method_name == method_name:
            consumer_impl = method
            break

    if consumer_impl is None:
        print("[+] Unable to find method", consumer)
        return

    print("[+] Finding producer for method", consumer)
    maybe_producers = apka.methods_jlong_ret_for_class(class_name, libhash=consumer_impl.libhash, lib_whitelist=libs, reachable=False)
    print("[+] Found %d possible producers" % len(maybe_producers))
    for maybe_producer in maybe_producers:
        print(maybe_producer)
        vtable = apka.vtable_from_jlong_ret(maybe_producer, use_angr=False)
        if vtable is not None:
            print("[!] Producer: %s %s %s @ %s %#x - vtable %#x" % \
                (maybe_producer.class_name, maybe_producer.method_name, maybe_producer.args_str, maybe_producer.libpath, maybe_producer.offset, vtable))
            break

def _find_vtable(apka, producer, libs=None, reachable=False):
    class_name  = "L" + "/".join(producer.split(".")[:-1]) + ";"
    method_name = producer.split(".")[-1]

    producer_impl = None
    for method in apka.find_native_methods_implementations(libs, reachable):
        if method.class_name == class_name and method.method_name == method_name:
            producer_impl = method
            break

    if producer_impl is None:
        print("[+] Unable to find method", producer)
        return

    print("[+] Finding vtable for producer", producer)
    vtable = apka.vtable_from_jlong_ret(producer_impl)
    if vtable is not None:
        print("[!] vtable:", hex(vtable))
    else:
        print("[!] vtable not found")

def main(args):
    apk_path = args.apk

    apka = APKAnalyzer(apk_path)
    reachable_analysis = False
    libs               = None
    if args.reachable:
        reachable_analysis = True
    if not args.all_archs:
        libs = apka.get_armv7_libs()
        libs = list(map(lambda l: l.libhash, libs))

    if args.print_native_functions:
        _print_native_functions(apka, libs, reachable_analysis)

    if args.find_producer is not None:
        _find_producer(apka, args.find_producer, libs, reachable_analysis)

    if args.find_vtable is not None:
        _find_vtable(apka, args.find_vtable, libs, reachable_analysis)

if __name__=="__main__":
    parser = argparse.ArgumentParser(description='Liana APK analyzer')
    parser.add_argument("--print-native-functions", help="Print native functions", action="store_true")
    parser.add_argument("--find-producer", help="Look for a producer given a consumer", nargs="?")
    parser.add_argument("--find-vtable", help="Look the returned vtable from a producer", nargs="?")
    parser.add_argument("--reachable", help="Analyze only reachable functions", action="store_true")
    parser.add_argument("--all-archs", help="Analyze all archs (not only armv7) [Experimental]", action="store_true")

    parser.add_argument("apk", help="The binary to analyze")

    args = parser.parse_args()

    exit(main(args))
