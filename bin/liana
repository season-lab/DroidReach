#!/usr/bin/env python3

import networkx as nx
import argparse
import sys
import os

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), ".."))
from apk_analyzer import APKAnalyzer
from apk_analyzer.utils import md5_hash
from cex_src.cex import CEXProject

def _print_native_functions(apka, libs=None, reachable=False):
    methods = None
    if reachable:
        methods = apka.find_reachable_native_methods()
    else:
        methods = apka.find_native_methods()

    for class_name, method_name, args_str in methods:
        print(" %s %s %s" % (class_name, method_name, args_str))
        native_impls = apka.find_native_implementations(method_name, class_name, args_str, libs)
        if len(native_impls) == 0:
            print("   * no implementation found")
            continue

        for native_impl in native_impls:
            print("   * %s\t%#x" % (native_impl.analyzer.libpath, native_impl.offset))

def _find_producer(apka, consumer, libs=None, reachable=False):
    class_name  = "L" + "/".join(consumer.split(".")[:-1]) + ";"
    method_name = consumer.split(".")[-1]

    consumer_impl = None
    for method in apka.find_native_methods_implementations(libs, reachable):
        if method.class_name == class_name and method.method_name == method_name:
            consumer_impl = method
            break

    if consumer_impl is None:
        print("[+] Unable to find method", consumer)
        return

    print("[+] Finding producer for method", consumer)
    maybe_producers = apka.find_potential_producers(consumer_impl, lib_whitelist=libs, reachable=False)
    print("[+] Found %d possible producers" % len(maybe_producers))
    for maybe_producer in maybe_producers:
        print(maybe_producer)
        vtable = apka.vtable_from_jlong_ret(maybe_producer, use_angr=False)
        if vtable is not None:
            print("[!] Producer: %s %s %s @ %s %#x - vtable %#x" % \
                (maybe_producer.class_name, maybe_producer.method_name, maybe_producer.args_str, maybe_producer.libpath, maybe_producer.offset, vtable))
            break

def _check_consumer(apka, consumer, libs=None):
    class_name  = "L" + "/".join(consumer.split(".")[:-1]) + ";"
    method_name = consumer.split(".")[-1]

    consumer_impl = None
    for method in apka.find_native_methods_implementations(libs):
        if method.class_name == class_name and method.method_name == method_name:
            consumer_impl = method
            break

    if consumer_impl is None:
        print("[+] Unable to find method", consumer)
        return

    print("[+] Checking if", consumer, "is a consumer")
    args = apka.jlong_as_cpp_obj(consumer_impl, use_angr=False)
    print("[!] The consumer uses the args %s as jlong pointers" % str(args))

def _find_vtable(apka, producer, libs=None, reachable=False):
    class_name  = "L" + "/".join(producer.split(".")[:-1]) + ";"
    method_name = producer.split(".")[-1]

    producer_impl = None
    for method in apka.find_native_methods_implementations(libs, reachable):
        if method.class_name == class_name and method.method_name == method_name:
            producer_impl = method
            break

    if producer_impl is None:
        print("[+] Unable to find method", producer)
        return

    print("[+] Finding vtable for producer", producer)
    vtable = apka.vtable_from_jlong_ret(producer_impl, use_angr=False)
    if vtable is not None:
        print("[!] vtable:", hex(vtable))
    else:
        print("[!] vtable not found")

def _find_path_to(apka, what, libs=None, reachable=False):
    lib, offset = what.split("@")
    offset = int(offset, 16)

    if libs is None:
        libs = apka.get_analyzed_libs()
    else:
        libs = apka.get_armv7_libs()
    lib_hashes = list(map(lambda l: l.libhash, libs))

    libhash = None
    for l in libs:
        if l.libname == lib:
            libhash = l.libhash
    if libhash is None:
        print("[!] Unable to find lib %s" % lib)
        return

    print("[+] Looking for path to %s @ %#x" % (lib, offset))

    print("[+] Building library dependency graph... ", end="")
    ldg = apka.build_lib_dependency_graph()
    print("OK")

    for method in apka.find_native_methods_implementations(lib_hashes, reachable):
        print("[+] Checking path from native method %s %s @ %s %#x" % \
            (method.class_name, method.method_name, method.libpath, method.offset))
        if not (method.libhash == libhash or nx.has_path(ldg, method.libhash, libhash)):
            print("[!] No path (lib dep graph)")
            continue

        main_lib   = method.libpath
        other_libs = list(map(lambda l: l.libpath, filter(lambda l: l.libpath != method.libpath, libs)))

        src_addr = method.offset & 0xfffffffe

        print("[+] Building the callgraph... ", end="")
        proj = CEXProject(main_lib, other_libs, plugins=["Ghidra", "AngrEmulated"])
        cg   = proj.get_callgraph(src_addr)
        print("[+] OK (n_nodes: %d, n_edges: %d)" % (len(cg.nodes), len(cg.edges)))

        binfo       = proj.get_bininfo(lib)
        rebased_off = offset + binfo.min_addr

        if rebased_off not in cg.nodes:
            print("[!] No path (addr not in callgraph)")
        elif nx.has_path(cg, src_addr, rebased_off):
            print("[+] Path found:")
            p = nx.shortest_path(cg, src_addr, rebased_off)
            print(" -> %s %s" % (method.class_name, method.method_name))
            for v in p:
                data = cg.nodes[v]["data"]
                print(" -> %s @ %#x" % (data.name, v))
            break
        else:
            print("[!] No path (callgraph)")

def _show_lib_dep_graph(apka):
    ldg = apka.build_lib_dependency_graph()

    print("digraph {\n\tnode [shape=box];")
    print("\tgraph [fontname = \"monospace\"];")
    print("\tnode  [fontname = \"monospace\"];")
    print("\tedge  [fontname = \"monospace\"];")

    for n in ldg.nodes:
        print("\t\"%s\" [label=\"%s\"];" % (n, ldg.nodes[n]["path"]))
    print()

    for src, dst, i in ldg.edges:
        if i != 0:
            continue
        print("\t\"%s\" -> \"%s\";" % (src, dst))
    print("}")


def main(args):
    apk_path = args.apk

    apka = APKAnalyzer(apk_path)
    reachable_analysis = False
    libs               = None
    if args.reachable:
        reachable_analysis = True
    if not args.all_archs:
        libs = apka.get_armv7_libs()
        libs = list(map(lambda l: l.libhash, libs))

    if args.print_native_functions:
        _print_native_functions(apka, libs, reachable_analysis)

    if args.find_producer is not None:
        _find_producer(apka, args.find_producer, libs, reachable_analysis)

    if args.check_consumer is not None:
        _check_consumer(apka, args.check_consumer, libs)

    if args.find_vtable is not None:
        _find_vtable(apka, args.find_vtable, libs, reachable_analysis)

    if args.find_path_to is not None:
        _find_path_to(apka, args.find_path_to, libs, reachable_analysis)

    if args.show_lib_dep_graph:
        _show_lib_dep_graph(apka)

if __name__=="__main__":
    parser = argparse.ArgumentParser(description='Liana APK analyzer')
    parser.add_argument("--print-native-functions", help="Print native functions", action="store_true")
    parser.add_argument("--check-consumer", help="Check if the method is a consumer", nargs="?")
    parser.add_argument("--find-producer", help="Look for a producer given a consumer", nargs="?")
    parser.add_argument("--find-vtable", help="Look the returned vtable from a producer", nargs="?")
    parser.add_argument("--reachable", help="Analyze only reachable functions", action="store_true")
    parser.add_argument("--all-archs", help="Analyze all archs (not only armv7) [Experimental]", action="store_true")
    parser.add_argument("--find-path-to", metavar="libpath.so@offset", help="Find path to native function", nargs="?")
    parser.add_argument("--show-lib-dep-graph", help="Print the library dependency graph in dot to stdout", action="store_true")

    parser.add_argument("apk", help="The binary to analyze")

    args = parser.parse_args()

    exit(main(args))
